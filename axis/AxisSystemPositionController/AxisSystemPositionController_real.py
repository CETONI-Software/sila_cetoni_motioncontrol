"""
________________________________________________________________________

:PROJECT: sila_cetoni

*Axis System Position Controller*

:details: AxisSystemPositionController:
    Allows to control the position of an axis system

:file:    AxisSystemPositionController_real.py
:authors: Florian Meinicke

:date: (creation)          2020-12-15T07:50:56.826849
:date: (last modification) 2020-12-15T07:50:56.826849

.. note:: Code generated by sila2codegenerator 0.2.0

________________________________________________________________________

**Copyright**:
  This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
  INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  For further Information see LICENSE file that comes with this distribution.
________________________________________________________________________
"""

__version__ = "0.1.0"

# import general packages
import logging
import time         # used for observables
import uuid         # used for observables
import grpc         # used for type hinting only

from typing import Any, Dict

# import SiLA2 library
import sila2lib.framework.SiLAFramework_pb2 as silaFW_pb2

# import SiLA errors
from impl.common.qmix_errors import DeviceError, SiLAFrameworkError, SiLAFrameworkErrorType, \
    SiLAValidationError, SiLAExecutionError

# import gRPC modules for this feature
from .gRPC import AxisSystemPositionController_pb2 as AxisSystemPositionController_pb2
# from .gRPC import AxisSystemPositionController_pb2_grpc as AxisSystemPositionController_pb2_grpc

# import default arguments
from .AxisSystemPositionController_default_arguments import default_dict

import math
import numpy as np
import shapely.geometry as geom
import shapely.ops as ops
# only for debugging the positioning shape
# from matplotlib import use
# use('Agg')
# import matplotlib.pyplot as plt

from qmixsdk.qmixmotion import Axis, AxisSystem

# noinspection PyPep8Naming,PyUnusedLocal
class AxisSystemPositionControllerReal:
    """
    Implementation of the *Axis System Position Controller* in *Real* mode
        Allows to control motion systems like axis systems
    """

    def __init__(self, axis_system: AxisSystem, device_properties: Dict[str, Any]):
        """
        Class initialiser.

        :param axis_system: The axis system that this feature shall operate on
        :param device_properties: Additional device properties that cannot be retrieved using QmixSDK functions
        """

        self.axis_system = axis_system
        self.movement_uuid = ''

        self.axes: Dict[str, Axis] = {
            self.axis_system.get_axis_device(i).get_device_name(): self.axis_system.get_axis_device(i)
            for i in range(self.axis_system.get_axes_count())
        }

        if 'jib_length' in device_properties:
            self.positioning_shape = \
                self._create_positioning_shape(device_properties['jib_length'])
        else:
            x_axis = self.axis_system.get_axis_device(0)
            y_axis = self.axis_system.get_axis_device(1)
            self.positioning_shape = geom.box(
                x_axis.get_position_min(),
                y_axis.get_position_min(),
                x_axis.get_position_max(),
                y_axis.get_position_max()
            )
        # plt.plot(*self.positioning_shape.exterior.xy)
        # plt.savefig('fig.png')

        PROPERTY_SAFE_ROTATION_HEIGHT = 0
        try:
            # safe rotation height only supported by rotAXYS (non-360) but not by others
            self.axis_system.set_device_property(PROPERTY_SAFE_ROTATION_HEIGHT, 1)
        except DeviceError:
            pass

        logging.debug('Started server in mode: {mode}'.format(mode='Real'))

    def _create_positioning_shape(self, jib_length):
        """
        Create the positioning shape that represents the valid space of (X, Y)
        coordinates for movement commands of the axis system

        :param jib_length: The capillary distance from the central axis of the pivot arm
        """

        if '360' in self.axis_system.get_device_name():
            # circular shape for rotAXYS360

            min_radius = self.axes['rotAXYS360_1_Radius'].get_position_min()
            max_radius = self.axes['rotAXYS360_1_Radius'].get_position_max()
            inner_radius = math.sqrt(min_radius ** 2 + jib_length ** 2)
            outer_radius = math.sqrt(max_radius ** 2 + jib_length ** 2)
            inner_circle = geom.Point(0, 0).buffer(inner_radius)
            outer_circle = geom.Point(0, 0).buffer(outer_radius)
            return geom.Polygon(outer_circle.exterior.coords, [inner_circle.exterior.coords])

        else:
            # arc-like shape for rotAXYS

            # the number of line segments to approximate an arc-like shape
            num_segments = 1000

            min_radius = self.axes['rotAXYS_1_Radius'].get_position_min()
            max_radius = self.axes['rotAXYS_1_Radius'].get_position_max()
            min_angle = self.axes['rotAXYS_1_Rotation'].get_position_min()
            max_angle = self.axes['rotAXYS_1_Rotation'].get_position_max()
            inner_angle = math.atan(jib_length / min_radius)
            outer_angle = math.atan(jib_length / max_radius)
            inner_angle_min = min_angle - inner_angle
            inner_angle_max = max_angle - inner_angle
            outer_angle_min = min_angle - outer_angle
            outer_angle_max = max_angle - outer_angle

            # the inner arc
            inner_radius = math.sqrt(min_radius ** 2 + jib_length ** 2) # 46.1546
            inner_start_angle = math.degrees(-inner_angle_min) # 151.767
            inner_end_angle = math.degrees(-inner_angle_max) # 46.8603
            inner_theta = np.radians(np.linspace(inner_start_angle, inner_end_angle, num_segments))
            inner_x = inner_radius * np.cos(inner_theta)
            # we need to invert this because the coordinate system has a Y-axis that is flipped
            inner_y = -inner_radius * np.sin(inner_theta)

            inner_arc = geom.LineString(np.column_stack([inner_x, inner_y]))

            # the outer arc
            outer_radius = math.sqrt(max_radius ** 2 + jib_length ** 2) # 145.617
            outer_start_angle = math.degrees(-outer_angle_min) # 135.913
            outer_end_angle = math.degrees(-outer_angle_max) # 31.0069
            outer_theta = np.radians(np.linspace(outer_start_angle, outer_end_angle, num_segments))
            outer_x = outer_radius * np.cos(outer_theta)
            # we need to invert this because the coordinate system has a Y-axis that is flipped
            outer_y = -outer_radius * np.sin(outer_theta)

            outer_arc = geom.LineString(np.column_stack([outer_x, outer_y]))

            # connect the first and last points of both arcs to get a closed shape
            left_bound = geom.LineString([inner_arc.coords[0], outer_arc.coords[0]])
            logging.debug(f"left_bound: {left_bound}")
            right_bound = geom.LineString([inner_arc.coords[-1], outer_arc.coords[-1]])
            logging.debug(f"right_bound: {right_bound}")

            return geom.Polygon(ops.linemerge([left_bound, inner_arc, outer_arc, right_bound]))

    def _ensure_stopped(self):
        """
        Checks if the axis system is currently moving and if so, stops all movement.
        """
        if self.movement_uuid:
            self.StopMoving(None, None)

    def _validate_uuid(self, uuid: silaFW_pb2.CommandExecutionUUID, check_premature_call = False):
        """
        Checks the given UUID for validity (i.e. if this is the UUID of the current
        movement command) and raises a SiLAFrameworkError if the UUID is not valid.
        Additionally, if `check_premature_call` is set to `True` then it is also
        checked that the axis system is not moving (this is only useful for
        `..._Result` functions). If this check fails, the corresponding FrameworkError
        will be raised, as well.

        :param uuid: The UUID to check
        :param check_premature_call: Whether to check if the axis system is still
                                     moving and raise an error if it is.
        """
        # catch invalid CommandExecutionUUID:
        if not uuid and self.movement_uuid != uuid:
            raise SiLAFrameworkError(
                SiLAFrameworkErrorType.INVALID_COMMAND_EXECUTION_UUID
            )

        # catch premature command call
        if check_premature_call and not self.axis_system.is_target_position_reached():
            raise SiLAFrameworkError(
                SiLAFrameworkErrorType.COMMAND_EXECUTION_NOT_FINISHED
            )

    def _validate_position(self, point: geom.Point):
        """
        Validates that the given point `point` lies within the positioning shape
        of the axis system. If this is not the case an appropriate SiLAValidationError
        will be raised.

        :param point: The point to validate
        """

        # plt.plot(*point.xy, 'bo')
        # plt.savefig('fig.png')

        if not point.within(self.positioning_shape):
            nearest_point, dummy = ops.nearest_points(self.positioning_shape, point)
            logging.debug(f"nearest: {nearest_point}, other: {dummy}")
            raise SiLAValidationError(
            'Position',
            f'The given Position {point.x, point.y} is not within the valid '\
            'positioning range for the axis system! The nearest valid position is '
            f'({nearest_point.x:.2f}, {nearest_point.y:.2f}).'
        )

    def _wait_movement_finished(self):
        """
        The function waits until the last movement command has finished
        """

        is_moving = True
        while is_moving:
            time.sleep(0.5)
            logging.info("Position: %s", self.axis_system.get_actual_position_xy())
            yield silaFW_pb2.ExecutionInfo(
                commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.running
            )
            is_moving = not self.axis_system.is_target_position_reached()

        if not is_moving:
            yield silaFW_pb2.ExecutionInfo(
                commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.finishedSuccessfully
            )
        else:
            yield silaFW_pb2.ExecutionInfo(
                commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.finishedWithError
            )
            logging.error("An unexpected error occurred: %s", self.axis_system.read_last_error())

    def MoveToPosition(self, request, context: grpc.ServicerContext) \
            -> silaFW_pb2.CommandConfirmation:
        """
        Executes the observable command "Move To Position"
            Move the axis system to the given position with a certain velocity

        :param request: gRPC request containing the parameters passed:
            request.Position (Position): The position to move to
            request.Velocity (Velocity): A real value between 0 (exclusive) and 100 (inclusive) defining the relative speed at which all axes of the axis system should move.The velocity value is multiplied with the maximum velocity value of each axis. So a value of 100 means, all axes travel with their maximum velocity. A value of 50 means, all axes travel with the half of the maximum velocity.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: A command confirmation object with the following information:
            commandId: A command id with which this observable command can be referenced in future calls
            lifetimeOfExecution: The (maximum) lifetime of this command call.
        """

        requested_position = geom.Point(
            request.Position.Position.X.value,
            request.Position.Position.Y.value
        )
        requested_velocity = request.Velocity.value

        self._ensure_stopped()
        self._validate_position(requested_position)

        self.movement_uuid = str(uuid.uuid4())
        command_uuid = silaFW_pb2.CommandExecutionUUID(value=self.movement_uuid)

        try:
            self.axis_system.move_to_postion_xy(requested_position.x, requested_position.y, requested_velocity / 100)
        except DeviceError as err:
            if err.errorcode == -1: # Operation not permitted
                raise SiLAExecutionError(
                    'MovementBlocked',
                    'The movement of the axis system is blocked and rotation is ' \
                    'not allowed. Rotation is only allowed if the upper limit sensor ' \
                    'is on - that means if the lift axis is in its topmost position.'
                )
            else:
                raise err


        logging.info(f"Started moving to {requested_position} with {requested_velocity}% of max velocity")

        # respond with UUID and lifetime of execution
        return silaFW_pb2.CommandConfirmation(
            commandExecutionUUID=command_uuid
        )

    def MoveToPosition_Info(self, request, context: grpc.ServicerContext) \
            -> silaFW_pb2.ExecutionInfo:
        """
        Returns execution information regarding the command call :meth:`~.MoveToPosition`.

        :param request: A request object with the following properties
            commandId: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: An ExecutionInfo response stream for the command with the following fields:
            commandStatus: Status of the command (enumeration)
            progressInfo: Information on the progress of the command (0 to 1)
            estimatedRemainingTime: Estimate of the remaining time required to run the command
            updatedLifetimeOfExecution: An update on the execution lifetime
        """
        # Get the UUID of the command
        self._validate_uuid(request.value)

        logging.info("Requested MoveToPosition_Info for movement (UUID: %s)", request.value)
        logging.info("Current movement is UUID: %s", self.movement_uuid)

        return self._wait_movement_finished()

    def MoveToPosition_Result(self, request, context: grpc.ServicerContext) \
            -> AxisSystemPositionController_pb2.MoveToPosition_Responses:
        """
        Returns the final result of the command call :meth:`~.MoveToPosition`.

        :param request: A request object with the following properties
            CommandExecutionUUID: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """

        # Get the UUID of the command
        self._validate_uuid(request.value, check_premature_call=True)

        logging.info("Finished moving! (UUID: %s)", self.movement_uuid)
        self.movement_uuid = ''
        time.sleep(0.6)

        return AxisSystemPositionController_pb2.MoveToPosition_Responses()


    def MoveToHomePosition(self, request, context: grpc.ServicerContext) \
            -> AxisSystemPositionController_pb2.MoveToHomePosition_Responses:
        """
        Executes the unobservable command "Move To Home Position"
            Move the axis system to its home position. The axis system should manage the order of the movement and should know how to move all axis into a home state.

        :param request: gRPC request containing the parameters passed:
            request.EmptyParameter (Empty Parameter): An empty parameter data type used if no parameter is required.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """

        self._ensure_stopped()
        time.sleep(0.6)
        self.axis_system.find_home()

        is_moving = True
        while is_moving:
            time.sleep(0.5)
            logging.info("Position: %s", self.axis_system.get_actual_position_xy())
            is_moving = not self.axis_system.is_homing_position_attained() \
                and not self.axis_system.is_target_position_reached()

        return AxisSystemPositionController_pb2.MoveToHomePosition_Responses()


    def StopMoving(self, request, context: grpc.ServicerContext) \
            -> AxisSystemPositionController_pb2.StopMoving_Responses:
        """
        Executes the unobservable command "Stop Moving"
            Immediately stops all movement of the axis system

        :param request: gRPC request containing the parameters passed:
            request.EmptyParameter (Empty Parameter): An empty parameter data type used if no parameter is required.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """

        self.axis_system.stop_move()

        return AxisSystemPositionController_pb2.StopMoving_Responses()


    def Subscribe_Position(self, request, context: grpc.ServicerContext) \
            -> AxisSystemPositionController_pb2.Subscribe_Position_Responses:
        """
        Requests the observable property Position
            The current XY position of the axis system

        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: A response object with the following fields:
            Position (Position): The current XY position of the axis system
        """

        while True:
            position = self.axis_system.get_actual_position_xy()

            yield AxisSystemPositionController_pb2.Subscribe_Position_Responses(
                Position=AxisSystemPositionController_pb2.DataType_Position(
                    Position=AxisSystemPositionController_pb2.DataType_Position.Position_Struct(
                        X=silaFW_pb2.Real(value=position.x),
                        Y=silaFW_pb2.Real(value=position.y)
                    )
                )
            )
            time.sleep(0.5) # give client some time to catch up
